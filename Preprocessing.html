<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>IoTGuard — Data Preprocessing</title>
  <style>
    :root{
      --max-width:1100px; --accent:#007BFF; --ok:#28a745; --warn:#ffc107; --danger:#dc3545;
      --card-bg:#fff; --muted:#666;
      --radius:10px; --pad:14px;
    }
    body{font-family:Arial, Helvetica, sans-serif; margin:0; background:#f5f7fb; color:#222;}
    .wrap{max-width:var(--max-width); margin:28px auto; padding:18px;}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;}
    h1{font-size:1.5rem;margin:0}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
    .card{background:var(--card-bg); padding:var(--pad); border-radius:var(--radius); box-shadow:0 6px 20px rgba(0,0,0,0.06);}
    pre{background:#0b1220;color:#e6eef8;padding:12px;border-radius:8px;overflow:auto}
    code{font-family:monospace; font-size:0.9rem}
    label{font-weight:700; display:block; margin-bottom:6px}
    input[type=file]{display:block;margin-bottom:8px}
    button{background:var(--accent); color:#fff; border:0; padding:8px 12px; border-radius:8px; cursor:pointer}
    button.secondary{background:#444}
    table{width:100%; border-collapse:collapse; font-size:0.9rem}
    th,td{border:1px solid #eee; padding:8px; text-align:left}
    th{background:#fafafa}
    .controls{display:flex; gap:8px; flex-wrap:wrap; margin:10px 0}
    .summary-msg{padding:12px;border-radius:8px;margin-top:10px}
    .summary-ok{background:#ecf9f0;color:var(--ok);border:1px solid rgba(40,167,69,0.12)}
    .summary-warn{background:#fff9ec;color:var(--warn);border:1px solid rgba(255,193,7,0.12)}
    .summary-danger{background:#fff0f0;color:var(--danger);border:1px solid rgba(220,53,69,0.12)}
    .small{font-size:0.85rem;color:var(--muted)}
    @media (max-width:980px){ .grid{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Data Preprocessing — IoTGuard</h1>
      <div class="small">Example: sensor_time,temperature,humidity,vibration</div>
    </header>

    <div class="grid">
      <!-- Left column: explanation + python recipe + interactive -->
      <div>
        <div class="card" aria-live="polite">
          <h2>What this page does</h2>
          <p class="small">
            This page shows common preprocessing for IoT sensor time-series data: cleaning, imputing missing values, outlier detection/removal,
            and feature engineering (rolling mean, differences, normalization). Use the Python recipe to run offline and the interactive demo
            to try preprocessing in your browser.
          </p>
        </div>

        <div class="card" style="margin-top:12px">
          <h2>Python (pandas) Preprocessing Recipe</h2>
          <p class="small">Run in a Python environment (Anaconda / virtualenv). Replace column names as needed.</p>
<pre><code># Python 3.8+ example using pandas & numpy
import pandas as pd
import numpy as np
from scipy import stats

# load
df = pd.read_csv('sensor_data.csv', parse_dates=['sensor_time'])

# set time index
df = df.set_index('sensor_time').sort_index()

# 1) Basic cleaning: drop exact-duplicate rows
df = df[~df.index.duplicated(keep='first')]

# 2) Impute missing values
# Option A: forward-fill then back-fill for small gaps
df = df.ffill().bfill()

# Option B: numeric columns -> fill with median
num_cols = df.select_dtypes(include='number').columns
df[num_cols] = df[num_cols].fillna(df[num_cols].median())

# 3) Remove outliers (z-score)
z = np.abs(stats.zscore(df[num_cols], nan_policy='omit'))
mask = (z < 3).all(axis=1)   # keep rows where all numbers have z < 3
df = df[mask]

# 4) Feature engineering
# rolling mean / window (e.g., window=5 samples)
window = 5
for col in num_cols:
    df[f'{col}_roll_mean'] = df[col].rolling(window=window, min_periods=1).mean()
    df[f'{col}_diff'] = df[col].diff().fillna(0)
    # normalized (min-max)
    col_min = df[col].min()
    col_max = df[col].max()
    df[f'{col}_norm'] = (df[col] - col_min) / (col_max - col_min + 1e-9)

# 5) Save cleaned file
df.to_csv('sensor_data_cleaned.csv')
print('Saved sensor_data_cleaned.csv — rows:', len(df))</code></pre>
        </div>

        <div class="card" style="margin-top:12px" id="interactive-demo">
          <h2>Interactive Demo (browser)</h2>

          <label for="file">Upload CSV (or click "Load sample")</label>
          <input type="file" id="file" accept=".csv" />
          <div class="controls">
            <button id="load-sample">Load sample CSV</button>
            <button id="run-preprocess">Run Preprocessing</button>
            <button id="download-clean" class="secondary">Download Clean CSV</button>
            <button id="reset">Reset</button>
          </div>

          <div style="margin-top:10px;">
            <label>Preprocessing options</label>
            <div class="small">Imputation:
              <select id="impute-mode">
                <option value="mean">Fill numeric with mean</option>
                <option value="ffill">Forward-fill then back-fill</option>
                <option value="drop">Drop rows with missing</option>
              </select>
              &nbsp; Outlier method:
              <select id="outlier-mode">
                <option value="zscore">Z-score (remove z&gt;3)</option>
                <option value="iqr">IQR (remove outside 1.5×IQR)</option>
                <option value="none">None</option>
              </select>
            </div>
          </div>

          <div id="summary" class="summary-msg summary-warn" style="display:none"></div>

          <h3 style="margin-top:12px">Raw data (first 10 rows)</h3>
          <div id="raw-table" class="card" style="max-height:200px; overflow:auto"></div>

          <h3 style="margin-top:12px">Cleaned preview (first 10 rows)</h3>
          <div id="clean-table" class="card" style="max-height:200px; overflow:auto"></div>

        </div>
      </div>

      <!-- Right column: sample CSV + helpful messages -->
      <div>
        <div class="card">
          <h3>Sample CSV (sensor_time,temperature,humidity,vibration)</h3>
          <pre id="sample-csv" style="white-space:pre-wrap; font-size:0.9rem; background:#fbfdff; padding:10px; border-radius:6px;">
sensor_time,temperature,humidity,vibration
2025-11-04T09:00:00,45.2,55.1,0.5
2025-11-04T09:01:00,45.5,54.9,0.6
2025-11-04T09:02:00,,54.8,0.5
2025-11-04T09:03:00,47.0,NA,12.0
2025-11-04T09:04:00,46.8,56.0,0.4
2025-11-04T09:05:00,200.0,57.0,0.6
2025-11-04T09:06:00,46.2,57.2,0.5
2025-11-04T09:07:00,46.1,57.1,0.6
2025-11-04T09:08:00,46.3,57.0,0.5
2025-11-04T09:09:00,46.6,56.9,
          </pre>
          <div class="small">This sample contains missing values and an outlier (200.0 temperature) to show cleaning behavior.</div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Useful message (sulfule mesej)</h3>
          <p class="small">Below is an automatically-generated summary that explains what preprocessing did and whether dataset looks good for modeling.</p>
          <div id="useful-message" class="summary-msg summary-ok">
            No data loaded yet — click <strong>Load sample CSV</strong> or upload a CSV to see preprocessing summary.
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>Notes & next steps</h3>
          <ul class="small">
            <li>Adjust imputation depending on sensor characteristics (median for skewed data).</li>
            <li>Consider time-based resampling (e.g., per minute) if sensors send irregular timestamps.</li>
            <li>For production, use server-side pipelines (Python, Airflow) or stream processing (Kafka, Spark, Flink).</li>
            <li>Keep a copy of raw data; store cleaned datasets separately for reproducibility.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * Simple CSV parser -> array of objects
     ***********************/
    function parseCSV(text){
      const lines = text.trim().split(/\r?\n/).filter(Boolean);
      if(lines.length === 0) return [];
      const headers = lines[0].split(',').map(h => h.trim());
      const rows = [];
      for(let i=1;i<lines.length;i++){
        // naive split by comma (works for simple CSV)
        const cols = lines[i].split(',').map(c => c.trim());
        const obj = {};
        for(let j=0;j<headers.length;j++){
          obj[headers[j]] = cols[j] === undefined || cols[j] === '' ? null : cols[j];
        }
        rows.push(obj);
      }
      return { headers, rows };
    }

    function toCSV(headers, rows){
      const esc = v => (v===null||v===undefined) ? '' : String(v).replace(/\n/g,' ');
      const lines = [headers.join(',')];
      for(const r of rows){
        lines.push(headers.map(h=>esc(r[h])).join(','));
      }
      return lines.join('\n');
    }

    // convert numeric-like strings to numbers where appropriate (leaves timestamp as string)
    function coerceTypes(headers, rows){
      const numericCols = new Set();
      // detect numeric columns by sampling first few rows
      for(const h of headers){
        let numeric = true;
        for(let i=0;i<Math.min(rows.length,6);i++){
          const v = rows[i][h];
          if(v === null) continue;
          // treat ISO-like times as non-numeric
          if(/^\d{4}-\d{2}-\d{2}T/.test(v)) { numeric = false; break; }
          if(isNaN(Number(v))) { numeric = false; break; }
        }
        if(numeric) numericCols.add(h);
      }
      // convert
      for(const r of rows){
        for(const h of numericCols) r[h] = r[h] === null ? null : Number(r[h]);
      }
      return { headers, rows, numericCols: Array.from(numericCols) };
    }

    // render small HTML table (first N rows)
    function renderTable(container, headers, rows, limit=10){
      if(!rows || rows.length===0){ container.innerHTML = '<div class="small">No rows to display</div>'; return; }
      const use = rows.slice(0,limit);
      let html = '<table><thead><tr>';
      for(const h of headers) html += `<th>${h}</th>`;
      html += '</tr></thead><tbody>';
      for(const r of use){
        html += '<tr>';
        for(const h of headers) html += `<td>${r[h] === null || r[h] === undefined ? '' : r[h]}</td>`;
        html += '</tr>';
      }
      html += '</tbody></table>';
      container.innerHTML = html;
    }

    /***********************
     * Preprocessing functions
     ***********************/
    function impute(rows, numericCols, mode='mean'){
      if(mode === 'drop'){
        return rows.filter(r => {
          for(const h of numericCols) if(r[h] === null || r[h] === undefined || Number.isNaN(r[h])) return false;
          return true;
        });
      }
      if(mode === 'ffill'){
        // forward fill then backward fill per column
        for(const h of numericCols){
          let last = null;
          for(const r of rows){
            if(r[h] === null || r[h] === undefined || Number.isNaN(r[h])) r[h] = last;
            else last = r[h];
          }
          // backfill from end
          let next = null;
          for(let i=rows.length-1;i>=0;i--){
            if(rows[i][h] === null || rows[i][h] === undefined || Number.isNaN(rows[i][h])) rows[i][h] = next;
            else next = rows[i][h];
          }
        }
        return rows;
      }
      // default: mean
      const means = {};
      for(const h of numericCols){
        const vals = rows.map(r=>r[h]).filter(v=>v!==null && v!==undefined && !Number.isNaN(v));
        means[h] = vals.length ? (vals.reduce((a,b)=>a+b,0)/vals.length) : 0;
      }
      for(const r of rows) for(const h of numericCols) if(r[h]===null||r[h]===undefined||Number.isNaN(r[h])) r[h] = means[h];
      return rows;
    }

    function removeOutliers(rows, numericCols, method='zscore'){
      if(method === 'none') return rows;
      if(method === 'iqr'){
        // remove rows where any numeric col outside 1.5*IQR
        const stats = {};
        for(const h of numericCols){
          const vals = rows.map(r=>r[h]).filter(v=>v!==null && !Number.isNaN(v)).sort((a,b)=>a-b);
          const q1 = vals[Math.floor((vals.length-1)*0.25)] ?? vals[0] ?? 0;
          const q3 = vals[Math.floor((vals.length-1)*0.75)] ?? vals[vals.length-1] ?? 0;
          const iqr = q3 - q1;
          stats[h] = { q1, q3, low:q1 - 1.5*iqr, high:q3 + 1.5*iqr };
        }
        return rows.filter(r=>{
          for(const h of numericCols){
            const v = r[h];
            if(v === null || v === undefined || Number.isNaN(v)) return false;
            if(v < stats[h].low || v > stats[h].high) return false;
          }
          return true;
        });
      }
      // zscore
      const means = {};
      const sds = {};
      for(const h of numericCols){
        const vals = rows.map(r=>r[h]).filter(v=>v!==null && !Number.isNaN(v));
        const mean = vals.reduce((a,b)=>a+b,0) / (vals.length || 1);
        const sd = Math.sqrt(vals.reduce((a,b)=>a+(b-mean)*(b-mean),0) / (vals.length || 1));
        means[h] = mean; sds[h] = sd || 1;
      }
      return rows.filter(r=>{
        for(const h of numericCols){
          const v = r[h];
          if(v === null || v === undefined || Number.isNaN(v)) return false;
          const z = Math.abs((v - means[h]) / sds[h]);
          if(z > 3) return false;
        }
        return true;
      });
    }

    function featureEngineering(rows, numericCols){
      // rolling mean (window=3), diff, min-max normalization per column
      const window = 3;
      // compute rolling mean per numeric col
      for(const h of numericCols){
        // create an array of values
        const vals = rows.map(r=>Number(r[h]));
        // rolling mean
        for(let i=0;i<rows.length;i++){
          const slice = vals.slice(Math.max(0,i-window+1), i+1);
          const mean = slice.reduce((a,b)=>a+b,0)/slice.length;
          rows[i][h + '_roll'] = Math.round(mean*100)/100;
          // diff
          rows[i][h + '_diff'] = i===0 ? 0 : Math.round((vals[i]-vals[i-1])*100)/100;
        }
        // normalization
        const min = Math.min(...vals);
        const max = Math.max(...vals);
        for(let i=0;i<rows.length;i++){
          rows[i][h + '_norm'] = Math.round(((rows[i][h] - min) / (max - min || 1))*1000)/1000;
        }
      }
      return rows;
    }

    // compute summary message & dataset health
    function computeSummary(rows, headers, numericCols){
      if(!rows || rows.length===0) return { level:'danger', text:'No rows remain after preprocessing.' };
      const issues = [];
      // missing count
      let missing = 0;
      for(const r of rows) for(const h of headers) if(r[h] === null || r[h] === undefined || Number.isNaN(r[h])) missing++;
      if(missing > 0) issues.push(`${missing} missing entries remain`);

      // check ranges for numeric columns (example: unrealistic temp)
      for(const h of numericCols){
        const vals = rows.map(r=>r[h]).filter(v=>v!==null && v!==undefined && !Number.isNaN(v));
        if(vals.length === 0) { issues.push(`${h} has no numeric values`); continue; }
        const min = Math.min(...vals), max = Math.max(...vals);
        if(Math.abs(max - min) < 1e-6) issues.push(`${h} is constant (no variance)`);
        // heuristics: temperature example
        if(h.toLowerCase().includes('temp') && (min < -50 || max > 150)) issues.push(`Temperature range suspicious: ${min}..${max}`);
      }
      if(issues.length === 0) return { level:'ok', text:`Dataset cleaned: ${rows.length} rows, ${numericCols.length} numeric columns. Ready for modeling.` };
      return { level: issues.length > 2 ? 'warn' : 'ok', text: `Processed: ${rows.length} rows. Notes: ` + issues.join('; ') };
    }

    /***********************
     * Wire up UI
     ***********************/
    const fileInput = document.getElementById('file');
    const loadSampleBtn = document.getElementById('load-sample');
    const rawTable = document.getElementById('raw-table');
    const cleanTable = document.getElementById('clean-table');
    const runBtn = document.getElementById('run-preprocess');
    const downloadBtn = document.getElementById('download-clean');
    const resetBtn = document.getElementById('reset');
    const imputeMode = document.getElementById('impute-mode');
    const outlierMode = document.getElementById('outlier-mode');
    const summaryEl = document.getElementById('summary');
    const usefulMessageEl = document.getElementById('useful-message');

    let current = { headers: [], rows: [], numericCols: [] };
    let cleaned = null;

    loadSampleBtn.addEventListener('click', ()=>{
      const sample = document.getElementById('sample-csv').textContent.trim();
      const parsed = parseCSV(sample);
      const coerced = coerceTypes(parsed.headers, parsed.rows);
      current = coerced;
      renderTable(rawTable, current.headers, current.rows);
      cleanTable.innerHTML = '<div class="small">No cleaned data yet</div>';
      summaryEl.style.display = 'none';
      usefulMessageEl.className = 'summary-msg summary-warn';
      usefulMessageEl.innerHTML = 'Sample loaded. Click <strong>Run Preprocessing</strong> to clean and create features.';
    });

    fileInput.addEventListener('change', (ev)=>{
      const f = ev.target.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = e=>{
        try{
          const parsed = parseCSV(String(e.target.result));
          const coerced = coerceTypes(parsed.headers, parsed.rows);
          current = coerced;
          renderTable(rawTable, current.headers, current.rows);
          cleanTable.innerHTML = '<div class="small">No cleaned data yet</div>';
          summaryEl.style.display = 'none';
          usefulMessageEl.className = 'summary-msg summary-warn';
          usefulMessageEl.innerHTML = `File loaded (${f.name}). ${current.rows.length} rows detected. Click Run Preprocessing.`;
        }catch(err){
          usefulMessageEl.className = 'summary-msg summary-danger';
          usefulMessageEl.innerHTML = 'Error parsing CSV: ' + (err.message || err);
        }
      };
      reader.readAsText(f);
    });

    runBtn.addEventListener('click', ()=>{
      if(!current || !current.headers || current.rows.length===0){
        usefulMessageEl.className = 'summary-msg summary-danger';
        usefulMessageEl.innerHTML = 'No data loaded. Load the sample or upload your CSV first.';
        return;
      }
      // clone rows deeply to avoid mutating original preview
      let rows = current.rows.map(r => Object.assign({}, r));
      const numericCols = current.numericCols;

      // impute
      rows = impute(rows, numericCols, imputeMode.value);

      // outliers
      rows = removeOutliers(rows, numericCols, outlierMode.value);

      // feature engineering
      rows = featureEngineering(rows, numericCols);

      // build new headers
      const newHeaders = [...current.headers];
      // append feature headers
      for(const h of numericCols){
        newHeaders.push(h + '_roll', h + '_diff', h + '_norm');
      }

      cleaned = { headers: newHeaders, rows };

      renderTable(cleanTable, cleaned.headers, cleaned.rows);
      const summary = computeSummary(cleaned.rows, cleaned.headers, numericCols);
      // show summary area and useful-message
      summaryEl.style.display = 'block';
      summaryEl.className = 'summary-msg ' + (summary.level === 'ok' ? 'summary-ok' : (summary.level === 'warn' ? 'summary-warn' : 'summary-danger'));
      summaryEl.textContent = summary.text;

      usefulMessageEl.className = 'summary-msg ' + (summary.level === 'ok' ? 'summary-ok' : (summary.level === 'warn' ? 'summary-warn' : 'summary-danger'));
      usefulMessageEl.innerHTML = `<strong>Preprocessing complete.</strong><br/>${summary.text} <div class="small" style="margin-top:6px">Actions: downloaded cleaned CSV or run additional preprocessing as needed.</div>`;
    });

    downloadBtn.addEventListener('click', ()=>{
      if(!cleaned){ alert('No cleaned data to download. Run preprocessing first.'); return; }
      const csv = toCSV(cleaned.headers, cleaned.rows);
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'sensor_data_cleaned.csv'; document.body.appendChild(a); a.click();
      a.remove(); URL.revokeObjectURL(url);
    });

    resetBtn.addEventListener('click', ()=>{
      current = { headers: [], rows: [], numericCols: []};
      cleaned = null;
      rawTable.innerHTML = '';
      cleanTable.innerHTML = '<div class="small">No cleaned data yet</div>';
      summaryEl.style.display = 'none';
      usefulMessageEl.className = 'summary-msg summary-ok';
      usefulMessageEl.innerHTML = 'Reset complete. Load a CSV to begin.';
      fileInput.value = '';
    });

    // initial message
    usefulMessageEl.innerHTML = 'No data loaded yet — click <strong>Load sample CSV</strong> or upload a CSV to see preprocessing summary.';
  </script>
</body>
</html>
